{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>This project provides a simple implementation of the state management pattern for angular applications.</p> <p>Definition from AOE</p> <p>State Management is a design pattern with the goal of properly sharing state data across components and separating domain representation from state management. This pattern is applied by many popular web frameworks such as Vuex, Redux or Flux.</p> <p>Especially in reactive systems, this pattern helps to solve the task of maintaining decoupled, stateless components with immutable data. The ways of implementing state management differs and depends on the specific requirements of the application at hand.</p> <p>There are already plenty solutions to do that (NgRx, NGXS, akita...). So why another implementation?</p> <p>Maybe the answer is to provide a really simple implementation based on existing libraries and made for Angular application only, an implementation that does what we expect and not more.</p> <p>The implementation is inspired from Redux.</p> <p> </p> <ul> <li>The registration of all the active objects is made by using the dependency injection of angular;</li> <li>The update of the state uses immutability-helper;</li> <li>The state notifications are based on RxJS.</li> </ul> <p>To use this state management implementation, install the packages and add the following in your app.config.ts file: </p> <pre><code>provideNgssmStore()\n</code></pre>"},{"location":"state/","title":"State and feature state","text":"<p>The state is the global object that contains all data to be shared among components and with a lifetime greater than a component's lifetime.</p> <p>The state contains all the defined feature states.</p> State<pre><code>export type State = Record&lt;string, object&gt;;\n</code></pre> <p>Note</p> <p>The state must be immutable but, to keep it simple, the state remains a simple javascript object. This is the responsibility of the coder to guarantee immutability of the state.</p>"},{"location":"state/#static-definition-of-a-feature-state","title":"Static definition of a feature state","text":"<p>The static way of providing a feature state is to use the decorator NgSsmFeatureState.</p> <pre><code>const featureStateSpecifications: FeatureStateSpecification[] = [];\nexport const NgSsmFeatureState = (specification: FeatureStateSpecification) =&gt; {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  return (target: object) =&gt; {\n    featureStateSpecifications.push(specification);\n</code></pre> <p>A feature state can be generated with schematics. For example:</p> <pre><code>ng g ngssm-schematics:feature-state testFeatureState\n</code></pre> <p>with the generated file</p> <pre><code>import update, { Spec } from 'immutability-helper';\n\nimport { NgSsmFeatureState, State } from 'ngssm-store';\n\nexport const selectTestFeatureStateState = (state: State): TestFeatureStateState =&gt;\n  state[TestFeatureStateStateSpecification.featureStateKey] as TestFeatureStateState;\n\nexport const updateTestFeatureStateState = (state: State, command: Spec&lt;TestFeatureStateState, never&gt;): State =&gt;\n  update(state, {\n    [TestFeatureStateStateSpecification.featureStateKey]: command\n  });\n\nexport interface TestFeatureStateState {}\n\n@NgSsmFeatureState({\n  featureStateKey: TestFeatureStateStateSpecification.featureStateKey,\n  initialState: TestFeatureStateStateSpecification.initialState\n})\nexport class TestFeatureStateStateSpecification {\n  public static readonly featureStateKey = 'test-feature-state-state';\n  public static readonly initialState: TestFeatureStateState = {};\n}\n</code></pre>"},{"location":"state/#dynamic-registration-of-a-feature-state","title":"Dynamic registration of a feature state","text":"<p>In order to allow associating a feature state to a component and so, to remove that state when the component is destroyed, a feature state could also be registered at any time.</p> <p>Note</p> <p>As the static registration of feature state will be removed in a future release, this is the way to register any feature state.</p> <p>Two actions are provided to register and unregister feature state:</p> <pre><code>import { Action } from '../action';\nimport { NgssmStoreActionType } from './ngssm-store-action-type';\n\nexport class NgssmRegisterFeatureStateAction implements Action {\n  public readonly type: string = NgssmStoreActionType.registerFeatureState;\n\n  constructor(\n    public readonly featureStateKey: string,\n    public readonly initialValue: object\n  ) {}\n}\n\n\nexport class NgssmUnregisterFeatureStateAction implements Action {\n  public readonly type: string = NgssmStoreActionType.unregisterFeatureState;\n\n  constructor(public readonly featureStateKey: string) {}\n}\n</code></pre> <p>When using a global feature state, one can use the function provideNgssmFeatureState as follows</p> <pre><code>export const appConfig: ApplicationConfig = {\n  providers: [provideNgssmFeatureState('my-feature-state', { description: 'something' })]\n};\n</code></pre> <p>When using a feature state with a component lifetime, one can use the directive ProvideNgssmFeatureStateDirective as follows</p> <pre><code>import { Component } from '@angular/core';\nimport { ProvideNgssmFeatureStateDirective } from './provide-ngssm-feature-state.directive';\nimport { FeatureStateSpecification, NGSSM_COMPONENT_WITH_FEATURE_STATE } from './feature-state-specification';\n\n@Component({\n  selector: 'ngssm-provide-ngssm-feature-state-directive-test',\n  imports: [],\n  template: ` &lt;p&gt;provide-ngssm-feature-state-directive-test works!&lt;/p&gt; `,\n  styles: ``,\n  hostDirectives: [ProvideNgssmFeatureStateDirective],\n  providers: [\n    {\n      provide: NGSSM_COMPONENT_WITH_FEATURE_STATE,\n      multi: false,\n      useExisting: ProvideNgssmFeatureStateDirectiveTestComponent\n    }\n  ]\n})\nexport class ProvideNgssmFeatureStateDirectiveTestComponent implements FeatureStateSpecification {\n  featureStateKey = 'my-feature-state';\n\n  initialState = {\n    id: 'testing'\n  };\n}\n</code></pre>"},{"location":"libraries/ngssm-data-simple-use-case/","title":"Using a data source","text":""},{"location":"libraries/ngssm-data-simple-use-case/#defining-the-model-and-the-loader","title":"Defining the model and the loader","text":"<pre><code>import { inject } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\nimport { NgssmDataLoading } from 'ngssm-data';\n\nexport const alertRulesKey = '@ngssm-data-demo:alert-rules';\nexport const alertRulesUrl = '/data/alert-rules.json';\n\nexport type AlertLevel = 'Info' | 'Warning' | 'Error';\n\nexport interface AlertRule {\n  id: number;\n  title: string;\n  level: AlertLevel;\n}\n\nexport const alertRulesLoader: NgssmDataLoading&lt;AlertRule[]&gt; = () =&gt; {\n  return inject(HttpClient).get&lt;AlertRule[]&gt;(alertRulesUrl);\n};\n</code></pre>"},{"location":"libraries/ngssm-data-simple-use-case/#registering-the-data-source","title":"Registering the data source","text":"<pre><code>import { ApplicationConfig, provideZoneChangeDetection } from '@angular/core';\nimport { provideRouter, withComponentInputBinding, withHashLocation } from '@angular/router';\nimport { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http';\n\nimport { provideConsoleAppender } from 'ngssm-store';\nimport { provideNgssmAgGrid } from 'ngssm-ag-grid';\nimport { provideNgssmData, provideNgssmDataSource } from 'ngssm-data';\n\nimport { routes } from './app.routes';\nimport { alertRulesKey, alertRulesLoader } from './model/alert-rule';\n\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideZoneChangeDetection({ eventCoalescing: true }),\n    provideRouter(routes, withHashLocation(), withComponentInputBinding()),\n    provideHttpClient(withInterceptorsFromDi()),\n    provideConsoleAppender('ngssm-data-demo'),\n    provideNgssmAgGrid(),\n    provideNgssmData(),\n    provideNgssmDataSource(alertRulesKey, alertRulesLoader)\n  ]\n};\n</code></pre>"},{"location":"libraries/ngssm-data-simple-use-case/#displaying-the-data","title":"Displaying the data","text":"htmlts <pre><code>&lt;mat-card class=\"fxFlex flex-column-stretch\"&gt;\n  &lt;mat-card-header&gt;\n    &lt;mat-card-title class=\"flex-row-center\"&gt;\n      Alert rules\n      &lt;ngssm-data-reload-button [dataSourceKeys]=\"[alertRulesSource.key]\"&gt;&lt;/ngssm-data-reload-button&gt;\n    &lt;/mat-card-title&gt;\n  &lt;/mat-card-header&gt;\n  &lt;mat-card-content class=\"fxFlex flex-column-stretch\"&gt;\n    &lt;ag-grid-angular [gridOptions]=\"gridOptions\" [rowData]=\"alertRulesSource.value()\" ngssmAgGridTheme class=\"fxFlex\"&gt; &lt;/ag-grid-angular&gt;\n  &lt;/mat-card-content&gt;\n&lt;/mat-card&gt;\n</code></pre> <pre><code>import { ChangeDetectionStrategy, Component } from '@angular/core';\nimport { MatCard, MatCardContent, MatCardHeader, MatCardTitle } from '@angular/material/card';\n\nimport { AgGridAngular } from 'ag-grid-angular';\nimport { GridOptions, ValueGetterParams } from 'ag-grid-community';\n\nimport { NgssmAgGridThemeDirective } from 'ngssm-ag-grid';\nimport { dataSourceToSignal, NgssmDataReloadButtonComponent } from 'ngssm-data';\n\nimport { AlertRule, alertRulesKey } from '../../model';\n\n@Component({\n  selector: 'app-alert-rules',\n  imports: [MatCard, MatCardHeader, MatCardTitle, MatCardContent, AgGridAngular, NgssmDataReloadButtonComponent, NgssmAgGridThemeDirective],\n  templateUrl: './alert-rules.component.html',\n  styleUrl: './alert-rules.component.scss',\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class AlertRulesComponent {\n  public readonly alertRulesSource = dataSourceToSignal&lt;AlertRule[]&gt;(alertRulesKey, {\n    type: 'value',\n    defaultValue: []\n  });\n\n  public readonly gridOptions: GridOptions = {\n    columnDefs: [\n      {\n        headerName: 'Id',\n        valueGetter: (params: ValueGetterParams&lt;AlertRule&gt;) =&gt; params.data?.id\n      },\n      {\n        headerName: 'Level',\n        valueGetter: (params: ValueGetterParams&lt;AlertRule&gt;) =&gt; params.data?.level\n      },\n      {\n        headerName: 'Title',\n        valueGetter: (params: ValueGetterParams&lt;AlertRule&gt;) =&gt; params.data?.title,\n        width: 400\n      }\n    ]\n  };\n}\n</code></pre>"},{"location":"libraries/ngssm-data/","title":"Overview","text":"<p>This library provides states, components and helpers to simplify management of data loaded from remote services or computed from any source.</p> <p>To use it, simply add provideNgssmData() in app.config.ts.</p> <pre><code>export const appConfig: ApplicationConfig = {\n  providers: [\n    ....\n    provideNgssmData();\n    ....\n  ]\n};\n</code></pre> <p>Note</p> <p>This library is provided as a replacement of ngssm-remote-data.</p> <p>Warning</p> <p>This library is currently under development.</p>"},{"location":"libraries/ngssm-data/#data-source","title":"Data Source","text":"<p>A data source is defined as:</p> <pre><code>classDiagram\n    class NgssmDataLoading~TData, TParameter~{\n        &lt;&lt;interface&gt;&gt;\n        loadData(state:State, dataSourceKey: string, parameter?: TParameter = undefined): Observable&lt;TData&gt;\n    }\n\n    class NgssmAdditionalPropertyLoading~TData~{\n        &lt;&lt;interface&gt;&gt;\n        loadData(state:State, dataSourceKey: string, additionalProperty:string): Observable&lt;TData&gt;\n    }\n\n    class NgssmDataSource~TData, TParameter~{\n        &lt;&lt;interface&gt;&gt;\n        key: string\n        dataLifetimeInSeconds?: number\n    }\n\n    NgssmDataSource --&gt; NgssmDataLoading\n    NgssmDataSource --&gt; \"0,1\" NgssmAdditionalPropertyLoading</code></pre> <ul> <li>key: unique identifer of the data source;</li> <li>dataLifetimeInSeconds: lifetime of the stored data in seconds;</li> <li>loadData: a function used to load the data. The parameter is optional.</li> </ul> <p>The data source must be registered with the function provideNgssmDataSource.</p> <pre><code>const dataLoader:NgssmDataLoading&lt;string[], number&gt; = (state:State, parameter?:number) : Observable&lt;string[]&gt; =&gt; {\n    const query = selectMyQuery(state);\n    return inject(HttpClient).post&lt;string[]&gt;(`${baseUrl}/${parameter}`, query);\n}\n\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideNgssmDataSource('doc:example:data', dataLoader, {dataLifetimeInSeconds: 6000});\n  ]\n};\n</code></pre> <p>A data source could also be added by using the action NgssmRegisterDataSource. It could then be removed with the action NgssmUnregisterDataSource.</p> <p>The value of a data source is stored in state as NgssmDataSourceValue</p> <pre><code>classDiagram\n    class NgssmDataSourceValueStatus{\n        &lt;&lt;enum&gt;&gt;\n        none\n        notRegistered\n        loading\n        loaded\n        error\n    }\n\n    note for NgssmDataSourceValueStatus \"notRegistered is used when we try to get value for a not registered data source\"\n\n    class NgssmDataSourceValue~TData, TParameter~{\n        &lt;&lt;interface&gt;&gt;\n        status: NgssmDataSourceValueStatus\n        value?: TData\n        parameter?: TParameter\n        lastLoadingDate?: Date\n    }\n\n    class NgssmDataSourceAdditionalPropertyValue~TProperty~{\n        &lt;&lt;interface&gt;&gt;\n        status: NgssmDataSourceValueStatus\n        value?: TProperty\n        lastLoadingDate?: Date\n    }\n\n    NgssmDataSourceValue --&gt; \"*\" NgssmDataSourceAdditionalPropertyValue</code></pre> <p>Additional properties of a data source</p> <p>Sometimes, some properties of the data source are not loaded at the same time as the data source itself. It's the case when we want to load detail part only when the user asks for it.</p> <p>It can be retrieved by</p> <pre><code>const value:NgssmDataSourceValue = selectNgssmDataSourceValue(state, 'doc:example:data');\n</code></pre> <p>Additional properties could be retirved from the data source value or by</p> <pre><code>const propertyValue:NgssmDataSourceAdditionalPropertyValue = selectNgssmDataSourceAdditionalPropertyValue(state, 'doc:example:data', propertyName);\n</code></pre>"},{"location":"libraries/ngssm-data/#actions","title":"Actions","text":"<p>Some actions are provided by the library to manage the data source.</p> <pre><code>export enum NgssmDataActionType {\n  // Used by the library to initialize all the data sources provided by the application\n  registerDataSources = '[NgssmDataActionType] registerDataSources',\n\n  // Could be used by the application to register or unregister a data source.\n  // This can be used, for example, to limit the lifetime of a data source to the lifetime of a component\n  registerDataSource = '[NgssmDataActionType] registerDataSource',\n  unregisterDataSource = '[NgssmDataActionType] unregisterDataSource',\n\n  // Used to call the loading method to get the value for the data source\n  loadDataSourceValue = '[NgssmDataActionType] loadDataSourceValue',\n\n  // Update the parameter used by the loading method, if one is required\n  setDataSourceParameter = '[NgssmDataActionType] setDataSourceParameter',\n\n  // Used to partially update the parameter. Usefull when creating a search component with multiple search criteria.\n  updateDataSourceParameter = '[NgssmDataActionType] updateDataSourceParameter',\n\n  // Update only the validity of the parameter. Usefull in case of a partial update of the parameter.\n  setDataSourceParameterValidity = '[NgssmDataActionType] setDataSourceParameterValidity',\n\n  // Clear the stored value associated to a data source\n  clearDataSourceValue = '[NgssmDataActionType] clearDataSourceValue',\n\n  // Store the value for a given data source\n  setDataSourceValue = '[NgssmDataActionType] setDataSourceValue',\n\n  // Call the loading method to get the value for an additional property of the data source\n  loadDataSourceAdditionalPropertyValue = '[NgssmDataActionType] loadDataSourceAdditionalPropertyValue',\n\n  // Store the value for an additional property of the data source\n  setDataSourceAdditionalPropertyValue = '[NgssmDataActionType] setDataSourceAdditionalPropertyValue'\n}\n</code></pre> <pre><code>store.dispatchAction(new NgssmLoadDataSourceValueAction('doc:example:data', { forceReload: true }));\nstore.dispatchAction(new NgssmSetDataSourceParameterAction('doc:example:data', 567));\nstore.dispatchAction(new NgssmClearDataSourceValueAction('doc:example:data'));\nstore.dispatchAction(new NgssmSetDataSourceValueAction('doc:example:data', NgssmDataSourceValueStatus.loaded, ['val1', 'val2']));\n</code></pre> <p>Note</p> <p>NgssmSetDataSourceValueAction should not be called by the application. This action is used by the library after the execution of the data source loading function.</p> <p>Note</p> <p>NgssmRegisterDataSourcesAction is used to register a list of data sources.</p> <p>At startup, the library registers itself the sources provided with the method provideNgssmDataSource.</p> <p>The action could be dispatch by the application when source is not known at startup or needs not to be defined at startup.</p> <p>If NgssmRegisterDataSourcesAction is dispatched for a data source already registered, nothing is done by the library.</p>"},{"location":"libraries/ngssm-data/#guard","title":"Guard","text":"<p>In case we need to reload the value of a data source when going to a given page, we can use the function ngssmLoadDataSourceValue.</p> <pre><code>export const myRoutes:Routes = [\n    {\n        path: 'example',\n        component: ExampleComponent,\n        canActivate : [\n            ngssmLoadDataSourceValue('doc:example:data', false)\n        ]\n    }\n]\n</code></pre> <p>The function will simply inject the store and dispatch the action NgssmLoadDataSourceValueAction.</p>"},{"location":"libraries/ngssm-data/#pipe","title":"Pipe","text":"<p>The pipe isNgssmDataSourceValueStatus is provided to allow updating the ui according to the status of a given data source value.</p> <pre><code>@if ( store.state() | isNgssmDataSourceValueStatus:'doc:example:data':'loading') {\n&lt;p&gt;The data is being loaded&lt;/p&gt;\n} @else if ( store.state() | isNgssmDataSourceValueStatus:'doc:example:data':'loaded':'error'){\n&lt;div&gt;Display the data&lt;/div&gt;\n}\n</code></pre>"},{"location":"libraries/ngssm-data/#components","title":"Components","text":"<ul> <li> <p>ngssm-data-reload-button</p> </li> <li> <p>used to reload a list of data sources;</p> </li> <li> <p>inputs:</p> <ul> <li>dataSourceKeys: string[] =&gt; the keys of the data sources managed by the button;</li> <li>keepAdditionalProperties: boolean =&gt; if true, additional properties are not cleared when reloading data;</li> <li>buttonIcon: string =&gt; css class to override default reload icon.</li> </ul> </li> </ul>"},{"location":"libraries/ngssm-store-caching/","title":"ngssm-store/caching","text":"<p>Helper to cache any object in the state without the need of implemented a specfic state with a specific reducer and specific actions.</p> <p>To use it, simply add provideNgssmCaching() in app.config.ts.</p> <pre><code>export const appConfig: ApplicationConfig = {\n  providers: [\n    ....\n    provideNgssmCaching();\n    ....\n  ]\n};\n</code></pre> <p>The data are stored as a <code>CachedItem&lt;TData&gt;</code>.</p> <pre><code>classDiagram\n\n    class CachedItemStatus{\n        &lt;&lt;enumeration&gt;&gt;\n        notSet,\n        loading,\n        set,\n        error\n    }\n\n    class CachedItem~TData~{\n        &lt;&lt;interface&gt;&gt;\n        status:CachedItemStatus\n        item?: TData\n        error?:string\n    }</code></pre> <p>To set or unset the cached item, the following actions are provided:</p> <ul> <li> <p><code>SetCachedItemAction&lt;TData = any&gt;</code>:</p> <ul> <li>cachedItemKey of type string is the key used as unique identifier of the cached item;</li> <li>cachedItem as <code>Partial&lt;CachedItem&lt;TData&gt;&gt;</code>. If the key does not exist, the value is set in the state. Otherwise, a merge is done with the value set in state.</li> </ul> </li> <li> <p><code>UnsetCachedItemAction</code>:</p> <ul> <li>cachedItemKey. The cached item is removed from the state.</li> </ul> </li> </ul> <p>To retrieve the cached item from the state, the function selectNgssmCachedItem is provided.</p> <pre><code>export const selectNgssmCachedItem = &lt;T&gt;(state: State, key: string): CachedItem&lt;T&gt; | undefined\n</code></pre>"},{"location":"libraries/ngssm-toolkit/","title":"ngssm-toolkit","text":"<p>This library provides helpers to avoid redundant code.</p>"},{"location":"libraries/ngssm-toolkit/#dialog-helper","title":"Dialog Helper","text":"<p>Helper used to open and close any component as dialog when some actions are triggered.</p> <p>To use this helper, the provideNgssmMatDialog function must be called in app.config.</p> <p>The feature can be configured through the function provideNgssmMatDialogConfigs with the input configuration:</p> <pre><code>classDiagram\n\n    class NgssmMatDialogConfig~TComponent, TDialog~{\n        openingAction: string;\n        closingActions: string[];\n        beforeOpeningDialog?: (state:State) =&gt; void;\n    }\n\n    class MatDialogConfig~TDialog~{\n\n    }\n\n    NgssmMatDialogConfig --&gt;\"0..1\" MatDialogConfig: matDialogConfig\n\n    class ComponentType~TComponent~{\n\n    }\n\n    NgssmMatDialogConfig --&gt; ComponentType: component\n</code></pre> <ul> <li>component is the component to be displayed as dialog;</li> <li>matDialogConfig is the options used by the MatDialog service to open the component as dialog;</li> <li>openingAction is the action triggering the rendering of the dialog;</li> <li>closingActions are the actions triggering the dialog to close.</li> </ul> <p>Note</p> <p>For now, an action can only close one dialog. The same action cannot be used to close different dialogs.</p>"}]}